![[monotone-sofa.svg]]

A sofa can be seen as the intersection of rotating hallways (see the figure above). So by taking a finite number of hallways and taking the polygonal intersection $S$, we get an approximation of the sofa with a larger area. Let $\Theta$ be a finite set of angles such that $\{0, \pi/2\} \subseteq \Theta \subseteq [0, \pi/2]$. That is, $\Theta$ is a partition
$$0 = \theta_0 < \theta_1 < \theta_2 < \cdots < \theta_n = \pi/2$$
of the interval $[0, \pi/2]$. `SofaDesigner` computes the set of all _monotone hallway intersections_ $S$ with the set of angles $\Theta$ and an area at least $2.2195\dots$.  Essentially, $S$ is the polygonal intersection of the finite number of hallways of width 1 rotated by each angle of $\Theta$, approximating a sofa from above (see the figure below).

`SofaDesigner` produces computer-assisted proofs of mathematical facts about an arbitrary intersection $S$. It generates proofs in computer files, so that the files representing the proofs can be verified separately by a verifier independent from `SofaDesigner`. The purpose of this is to ensure that the correctness of the proof do not depend on the correctness of the specific implementation of `SofaDesigner` (which consists of thousand lines of C++), and to enable cross-validation by multiple independent parties.

In particular, we have the following roles for `SofaDesigner` and its verifier.

- `SofaDesigner`
	1. Computes the set $\mathcal{S}$ of all monotone hallway intersections $S$ with an area at least $2.2195\dots$, and stores it as a tree structure $\mathcal{T}$ in a JSON format.
	2. Given $\mathcal{T}$ and an inequality $I$ on an arbitrary intersection $S$ in $\mathcal{S}$, produces a proof in a custom JSON format.
- The verifier
	1. Verifies that the JSON-formatted tree $\mathcal{T}$ accurately represents the set $\mathcal{S}$ of all monotone hallway intersections $S$ with an area at least $2.2195\dots$.
	2. Verifies the proof that an inequality $I$ on $\mathcal{S}$ from the JSON-formatted proof generated by `SofaDesigner`.

# Definition of Monotone Hallway Intersection $S$

> __Figure [polygon-hallway-intersection].__ An intersection $S$ with five hallways ($n=4$) and edge order $\mathbf{i}_K = [0, 1, 2, 3, -2, 2, -3, 1, -4, -2, 0]$. ^fig-polygon-hallway-intersection
> 
> ![70%](images/polygon-hallway-intersection.svg)

We first provide the precise definition and shape of a monotone hallway intersection $S$ with angle set $\Theta$. All the details in this section is important to ensure that the verification process is correct.

$H = \mathbb{R} \times [0, 1]$ is the horizontal strip of height 1. $L$ is the right-angled hallway of width 1, with inner corner at $\mathbf{x} = (0, 0)$ and outer corner at $\mathbf{y} = (1, 1)$. Mathematically, $L = (-\infty, 1] \times [0, 1] \cup [0, 1] \times (-\infty, 1]$. Let $a$ and $b$ be the lines $x=1$ and $y=1$ passing through the outer corner $\mathbf{y}$ representing the outer walls of $L$. Let $c$ and $d$ be the half-lines $(-\infty, 0] \times \left\{ 0 \right\}$ and $\left\{ 0 \right\} \times (-\infty, 0]$ emanating from the inner corner $\mathbf{x}$ representing the inner walls of $L$. 

For all $0 \leq i \leq n$, let $u_i = (\cos \theta_i, \sin \theta_i)$ and $v_i = (-\sin \theta_i, \cos \theta_i)$ so that the vectors $u_i$ and $v_i$ form a orthogonal basis. Also, let $v_{i + n} = - u_i$ for all $0 \leq i \leq n$ so that $v_i$ is defined for all indices $i$ from $0$ to $2n$. For any $0 \leq i \leq n$, let $L_i$ be a copy of the hallway $L$ rotated counterclockwise by an angle of $\theta_i$ and translated so that the inner corner is positioned at $\mathbf{x}_i$. Here, the set $S$ is the intersection of the horizontal strip $H$ and the rotated hallways $L_i$. Let $a_i$, $b_i$, $c_i$ and $d_i$ be the sides of the hallway $L_i$ corresponding to the sides $a, b, c,$ and $d$ of $L$.

For the intersection $S = H \cap \bigcap_{i=0}^n L_i$ to be a monotone hallway intersection, we require the following conditions. 

- (WLOG) Without loss of generality, by translating $S$ horizontally we assume that $L_0 = L$ so that $\mathbf{x}_0 = (0, 0)$. Also, we assume that $\mathbf{x}_n$ has the $y$-coordinate equal to zero. Consequently, the sides $a_n$ and $c_0$ are equal to the line $y=1$.
- (Monotonicity) The sides $y=0$ and $y=1$ of $H$ and the outer walls $a_i$ and $c_i$ of $L_i$ for any $0 \leq i \leq n$ should determine all the sides of a convex polygon $K$ called the _cap_ of $S$. Although we allow some edges of $K$ to degenerate and have zero length, all the lines $a_0, a_1, \dots, a_{n-1}, a_n = c_0, c_1, \dots, c_n$, and $y = 0$ should form the edges of $K$ in counterclockwise order.

Consequently, the sides $a_n$ and $c_0$ are equal to the line $y=1$ and determines the upper horizontal edge of $K$. The sides $a_0, a_1, \dots, a_{n-1}$ forms the different edge of $K$ on the right side in counterclockwise order, and the sides $c_1, c_2, \dots, c_n$ forms the different edges of $K$ on the right side in counterclockwise order.

For any $0 < i \leq n$, let $A_i$ be the intersection of $a_{i-1}$ and $a_i$. Also let $A_0$ be the intersection of $a_0$ and the line $y=0$. Likewise, for any $0 \leq i < n$, let $C_i$ be the intersection of $c_i$ and $c_{i+1}$. Also let $C_n$ be the intersection of $a_0$ and the line $y=0$. Then the points $A_0, A_1, \dots, A_n$ forms the vertices of $K$ on the right side, and the points $C_0, C_1, \dots, C_n$ forms the vertices of $K$ on the left side. For any $0 \leq i \leq n$, define $A_{n + 1 + i} = A_i$ so that the list $A_0, A_1, \dots, A_{2n + 1}$ forms all the vertices of $K$ in the counterclockwise order.

For any $0 \leq i \leq n$, define the support function values $p_i = A_i \cdot u_i$ and $q_i = C_i \cdot v_i$ of the cap $K$. Note that we also have $p_i = \mathbf{x}_i \cdot u_i + 1$ and $q_i = \mathbf{x}_i \cdot v_i + 1$. Note that as the sides $a_n$ and $c_0$ are equal to the line $y=1$, we have $p_n = q_0 = 1$. $0 \leq i \leq n$, define $p_{n+i} = q_i$ so that the list $p_0, p_1, \dots, p_{2n}$ is a concatenation of $p_0, p_1, \dots, p_n$ and $q_0, q_1, \dots, q_n$. For every $0 \leq i \leq 2n$, define the side lengths $s_i = (A_{i+1} - A_i) \cdot v_i$ of $K$.

# Coordinate Systems of $S$

A monotone hallway intersection $S$ is completely determined by its cap $K$. So the state of $S$ can be described by any coordinate system representing the cap $K$. There are three coordinate systems we can use for $K$.

- For every $0 \leq i \leq n$, the inner corners $\mathbf{x}_i = (x_i, y_i) \in \mathbb{R}^2$ of the hallways with $\mathbf{x}_0 = (x_0, y_0) = (0, 0)$ and the $y$-coordinate $y_n$ of $\mathbf{x}_n$ equal to zero. With the constraints we have a total of $2n-1$ free coordinates $x_1, \dots, x_n, y_1, \dots, y_{n-1}$ to determine.
- The support function values $p_0, p_1, \dots, p_n$ and $q_0, q_1, \dots, q_n$ of the right and left part of the cap, with constraints $p_0 = p_n = q_0 = 1$. In this coordinate, we have $2n-1$ free values $p_1, \dots, p_{n-1}$ and $q_1, \dots, q_{n}$ to determine.
- The edge lengths $s_0, s_1, \dots, s_{2n}$ of cap $K$, with constraints $\sum_{i=0}^n \cos(\theta_i) s_i = 1$ and $\sum_{i=0}^n \sin(\theta_i) s_{n+i} = 1$ to ensure that the height of $K$ is equal to 1. Using the two equalities, we can eliminate the variables $s_0 = 1 - \sum_{i=1}^n \cos(\theta_i) s_i$ and $s_{2n} = 1 - \sum_{i=0}^{n-1} \sin(\theta_i) s_{n+i}$ and have $2n-1$ free variables $s_1, s_2, \dots, s_{2n-1}$.

All three coordinate systems are convertible to each other. For example, the coordinates of $\mathbf{x}_i$ determine the values $p_i = \mathbf{x}_i \cdot u_i + 1$ and so the lines $a_i = \left\{ z \in \mathbb{R}^2 : z \cdot u_i = p_i \right\}$ and the intersections $A_i = a_{i-1} \cap a_{i}$. The side lengths are then recoverable from the formula $s_i = (A_{i+1} - A_i) \cdot v_i$. In this way, we can express the edge lengths $s_0, s_1, \dots, s_{2n}$ from the coordinates of $\mathbf{x}_0, \mathbf{x}_1, \dots, \mathbf{x}_n$. We can also work the other way and get the coordinates of $\mathbf{x}_i$ from the edge lengths $s_0, s_1, \dots, s_{2n}$. Start with $A_0 = (0, 0)$, and use the formula $A_{i+1} = A_i + s_i v_i$ to retrieve all the vertices $A_0, \dots, A_{2n}$ of $K$, the support function values $p_i = A_i \cdot u_i$ and $q_i = A_{i + n} \cdot v_n$, and then $\mathbf{x}_i = (p_i - 1) u_i + (q_i - 1) v_i$. Note that all the conversions are affine-linear. So any of the three coordinate systems determine a cap $K$. 

`SofaDesigner` chooses the system of support function values $p_1, \dots, p_{n-1}$ and $q_1, \dots, q_{n}$. Let $\mathbf{p} = (p_1, \dots, p_{n-1}, q_1, \dots, q_n)$ be the list of free variables in the given order. We also require each side length $s_i$ to be nonnegative in order for $K$ to be a proper cap. For any $0 \leq i \leq 2n$, let $E_i$ be the inequality $s_i \geq 0$ where $s_i$ is written in terms of $\mathbf{p}$. Define $\mathcal{K}_\Theta$ as the domain of $2n-1$ free real variables $\mathbf{p}$ in support function coordinates with the linear constraints $E_i$ for all $0 \leq i \leq n$. Then $\mathcal{K}_\Theta$ is the space of all caps of monotone hallway intersections with angle set $\Theta$. The goal of `SofaDesigner` is to understand the subset of $\mathcal{K}_\Theta$ where the cap gives rise to the monotone hallway intersection $S = H \cap \bigcap_{i=0}^n L_i$ of area at least $2.2195$.

# Area of $S$ by its Niche $\mathcal{N}(K)$

Let $\mathcal{A}(K)$ be the area of the monotone hallway intersection $S$ with cap $K \in \mathcal{K}_\Theta$. The goal of `SofaDesigner` is to understand the area functional $\mathcal{A} : \mathcal{K}_\Theta \to \mathbb{R}$ completely. Define the _niche_ $\mathcal{N}(K)$ of the monotone hallway intersection $S$ as the region bounded from below by the line $y=0$, and bounded from above by the upper envelope of the line $y=0$ and the half-lines $c_i$ and $d_i$ for all $0 \leq i \leq n$. For any set $X$, denote its area as $|X|$. Then the area $|S|$ of $S$ is equal to $\mathcal{A}(K) = |K| - \mathcal{N}(K)$ because $S$ is the cap $K$ subtracted by the union of inner corners $\mathcal{N}(K)$. Note that the area $|K|$ of cap is a quadratic polynomial in terms of the coordinates of $\mathcal{K}_\Theta$ (one can for example use the [shoelace formula](https://mathworld.wolfram.com/ShoelaceFormula.html)). However, the area of the niche $\mathcal{N}(K)$ is much harder to understand.

If the order of edges appearing in the niche $\mathcal{N}(K)$ is determined, we can understand the area $|\mathcal{N}(K)|$ as a quadratic polynomial of the coordinates of $K$. For every $0 \leq i \leq n$, define the line $l_i$ as the line extending the half-line $d_i$, and the line $l_{-i}$ as the line extending the half-line $b_{n-i}$ (note that $l_0$ is equal to the line $y=0$ in both cases). Let $\mathbf{i}_K$ be the list of all the indices $i$ of the lines $l_i$ appearing in the niche $\mathcal{N}(K)$ from left to right. So $\mathbf{i}_K$ is either a list of length one with only one zero, or a list with length at least two starting and ending with zero. If $-n \leq i , j \leq n$ are different indices, define the point $p_{i, j}$ as the intersection of the lines $l_i$ and $l_j$. Then the coordinates of points $p_{i, j}$ are affine-linear with respect to the coordinates $\mathbf{p}$ of $\mathcal{K}_\Theta$. If $\mathbf{i}_K$ is the list $i_1, i_2, \dots, i_m$, then the vertices of the niche are exactly $p_{i_1, i_2}, p_{i_2, i_3}, \dots, p_{i_{m-1}, i_m}$ from left to right with the first and last vertex on the line $y=0$. So by using the shoelace formula, we can express the area of the niche $\mathcal{N}(K)$ in terms of the quadratic polynomials of the coordinates of $p_{i, j}$'s, and thus the coordinates $\mathbf{p}$ of $\mathcal{K}_\Theta$.

# Branch-and-bound Tree $\mathcal{T}$

The difficulty with the niche $\mathcal{N}(K)$ is that the order $\mathbf{i}_K$ of the lines appearing in the niche can change drastically depending on the cap $K$. We need extra restrictions on the coordinates $\mathbf{p}$ of $K$ to ensure a niche with a fixed order $\mathbf{i}_K$ of lines. To this end, `SofaDesigner` uses a custom branch-and-bound algorithm to divide the set $\mathcal{K}_\Theta$ into small pieces where we can show that the order $\mathbf{i}_K$ is fixed. `SofaDesigner` then stores the branch-and-bound tree $\mathcal{T}$ in JSON-formatted files. The tree $\mathcal{T}$ represents the subset of $\mathcal{K}_\Theta$ where the area of the hallway intersection $S$ is at least $2.2195$. **The first main task of a verifier is to check that $\mathcal{T}$ stored as JSON files represents the subset of $\mathcal{K}_\Theta$ with hallway intersection area $\geq 2.2195$ correctly as described here**.

The tree $\mathcal{T}$ is a complete binary tree representing the subset of $\mathcal{K}_\Theta$ with $\mathcal{A} \geq 2.2195$. Each node $N_i$ is equipped with a finite set $I_i$ of affine-linear combinations of the coordinates $\mathbf{p}$. Each $f \in I_i$ represents the inequality $f \geq 0$, so that the node $N_i$ represents the subset $\mathcal{K}_i \subseteq \mathcal{K}_\Theta$ where the value of $f$ is non-negative for every $f \in I_i$. The root node $N_1$ of the tree $\mathcal{T}$ represents the whole $\mathcal{K}_\Theta$ with the constraints $I_i = {s_0, s_1, \dots, s_{2n}}$. Every non-leaf node $N_i$ is split into two child nodes $N_j$ and $N_k$ by the inequalities $g_i \geq 0$ and $-g_i \geq 0$ for some affine-linear combination $g_i$ of the coordinates $\mathbf{p}$. So, the constraints $I_j$ of node $N_j$ is $I_j = I_i \cup \left\{ g_i \right\}$, and the constraints $I_k$ of node $N_k$ is $I_k = I_i \cup \left\{-g_i  \right\}$. This ensures that the union of the sets $\mathcal{K}_i$ represented by the leaf nodes $N_i$ of $\mathcal{T}$ is equal to the whole space $\mathcal{K}_\Theta$. The first responsibility of a verifier is to ensure that the given $\mathcal{T}$ adheres to the structure described here.

Each leaf node $N_i$ have the linear constraints $I_i$ that describes the subset $\mathcal{K}_i$ of the cap space $\mathcal{K}_\Theta$. If the constraints $I_i$ are incompatible, then the set $\mathcal{K}_i$ is empty and we mark the node $N_i$ as _invalid_. A linear programming algorithm can check the consistency of $I_i$. 

If the constraints $I_i$ of $N_i$ are compatible, `SofaDesigner` produces the precise order $\mathbf{i}_i$ of lines appearing in the niche of arbitrary cap $K \in \mathcal{K}_i$ represented by the node $\mathcal{N}_i$. To verify the validity of $\mathbf{i}_i$, the verifier does not need to verify the inner workings of `SofaDesigner`. Instead, the verifier only needs to ensure that each edge of the polyline described by $\mathbf{i}_i$ does appear in the niche. Fix an arbitrary node $N_i$ and its index $i$. Let $x, y, z$ be any three consecutive numbers appearing in the list $\mathbf{i}_i$ of indices. Then we need to ensure that the edge $e$ connecting $p_{x, y}$ and $p_{y, z}$. is a part of the niche. In specific, we need to verify the followings.

- We need to ensure that the point $p_{y, z}$ is on the right side of $p_{x, y}$. That is, $(p_{y, z} - p_{x, y}) \cdot u_0 \geq 0$.
- We need to ensure that the edge $e$ is a part of either the half-lines $\mathbf{b}_i$ or $\mathbf{d}_i$.
	- If $y > 0$, we should check if $p_{y, z}$ is on the left side of $\mathbf{x}_y$ to ensure that $e$ is a part of $\mathbf{b}_i$. That is, $(\mathbf{x}_y - p_{y, z} ) \cdot u_0 \geq 0$.
	- If $y < 0$, we should check if $p_{x, y}$ is on the right side of $\mathbf{x}_y$ to ensure that $e$ is a part of $\mathbf{d}_i$. That is, $(p_{x, y} - \mathbf{x}_y) \cdot u_0 \geq 0$.

Note that all conditions we need to check above are linear inequalities. So by running linear programming with the constraints $I_i$, we can verify that the niche of the cap in node $N_i$ indeed contains the polyline described by edges in order $\mathbf{i}_i$. `SofaDesigner` runs the algorithm and generates certificates for such linear programming. So the verifier only needs to verify the certificate using arithmetics.

Once the edge order $\mathbf{i}_K = \mathbf{i}_i$ is verified for the node $N_i$, we can calculate the quadratic polynomial $f_i$ from the edge order. By running quadratic programming maximization of $f_i$ under the constraints $I_i$, we obtain the maximum possible area of the node $N_i$. But to do so, we also need to ensure that $f_i$ is convex. That is, the quadratic part of $f_i$ is negative-semidefinite. `SofaDesigner` verifies both the negative-semidefiniteness of $f_i$ and the correctness of quadratic programming using certificates. So the verifier only needs to check the certificates coming from `SofaDesigner`. If the maximum value of $f_i$ is less than $2.2195$, the node $N_i$ is again marked as _invalid_ because there is no cap $K \in \mathcal{K}_i$ that gives the intersection $S$ of possibly larger area than Gerver's sofa. Otherwise, the node $N_i$ is marked as _valid_. Finally, the collection of valid nodes $N_i$ with constraints $I_i$, niche edge order $\mathbf{i}_i$ forms a partition of the subset of $\mathcal{K}_\Theta$ with hallway intersection area $\geq 2.2195$.

## File Format of $\mathcal{T}$

We now describe the exact format of each file that `SofaDesigner` produces for the representation of branch-and-bound tree $\mathcal{T}$.

### Angles used in `angles.json`

The partition $\Theta = \theta_0, \theta_1, \dots, \theta_n$ of interval $[0, \pi/2]$ is given in the order in file `angles.json` as the following format of a single array.

```json
[
    {"cos": "4977/5105", "sin": "1136/5105", "branch_order": 4},
    {"cos": "8023/8905", "sin": "3864/8905", "branch_order": 2},
    {"cos": "351/449"  , "sin": "280/449"  , "branch_order": 0},
    {"cos": "280/449"  , "sin": "351/449"  , "branch_order": 1},
    {"cos": "3864/8905", "sin": "8023/8905", "branch_order": 3},
    {"cos": "1136/5105", "sin": "4977/5105", "branch_order": 5}
]

```

As the first angle $\theta_0 = 0$ and the last angle $\theta_n = \pi/2$ are fixed, the file `angles.json` only contains the remaining angles $\theta_1, \dots, \theta_{n-1}$ in the increasing order. Each angle is not given explicitly in radians or degrees. Instead, the angle's cosine and sine values are given as rational numbers. This is to ensure that all computations can be done with exact rational numbers. The entry `branch_order` can be ignored and it is only consumed by `SofaDesigner` internally. `SofaDesigner` consumes the `angles.json` file and produces the following files describing the tree $\mathcal{T}$.

### List of all linear functionals in `linear-values.json`

`SofaDesigner` uses a set of linear functionals on cap $K$ (that is, linear combinations of the coordinates of $K$) in multiple places. The main use of a linear functional $g$ is to split each node of $\mathcal{T}$ by whether $g \geq 0$ or $g \leq 0$ holds for an arbitrary cap $K \in \mathcal{K}_\Theta$. There are three kinds of values of $g$ possible.

- For every $0 \leq i \leq 2n$, the side length $s_i$ of $K$. 
	- The inequality $s_i \geq 0$ should always hold for every node.
- For every $0 \leq i < j < k$, the value $l_{i, j, k} = (\mathbf{x}_K - p_{i, j}) \cdot u_0$.
	- The inequality $l_{i, j, k} \geq 0$ (resp. $l_{i, j, k} \leq 0$) means that the point $p_{i, j}$ is on the left (resp. right) side of $\mathbf{x}_k$.
- For every $0 < i < j < k$, the value $o_{i, j, k} = p_{i, j} \cdot v_k - p_k + 1$. 
	- The inequality $o_{i, j, k} \geq 0$ means that the point $p_{i, j}$ is on or over the line $l_k$. 

It is the responsibility of the verifier to compute the exact values of the values above in terms of the coordinates of cap space $\mathcal{K}_\Theta$.

The file `linear-values.json` contains the list of all possible values of $g$. The index starts with one, and in other files we will use the index $i$ of $g$ in the list to denote the value of $g$. Sometimes we need to denote the negation $-g$, for which we denote by the negation of the index $i$. For example, the linear functional $o_{1, 2, 3}$ has index 44 in the list `linear-values.json`, then in other files the value $-44$ denotes the linear functional $-o_{1, 2, 3}$.

```json
["s 0", "s 1", "s 2", "s 3", "l 2 3 4", "l 4 5 6", "o 1 2 3"]
```

### Non-leaf nodes of $\mathcal{T}$ in `split-nodes.json`

Every non-leaf node of $\mathcal{T}$ is split into two smaller nodes by whether $g \geq 0$ or $g \leq 0$ holds for some linear functional $g$ in the list `linear-values.json`. We supply all such nodes in a dictionary `split-nodes.json`.

```json
{
    "N1" : {"split_by": 34, "child_geq" : "N34", "child_leq" : "N56"},
    "N1" : {"split_by": 34, "child_geq" : "N34", "child_leq" : "N56"},
    "N1" : {"split_by": 34, "child_geq" : "N34", "child_leq" : "N56"},
    ...
}
```

Every node of $\mathcal{T}$ is denoted by an ID that starts with the letter `N` followed by a nonnegative integer. The keys of dictionary `split-nodes.json` are all non-leaf nodes of $\mathcal{T}$. The value of each non-leaf node is a structure: `"split_by"` denotes the one-index of the linear functional $g$ used to split the node, `"child_geq"` is the ID of the child node with constraint $g \geq 0$ added, and `"child_leq"` is the ID of the child node with constraint $g \leq 0$ added.

### Leaf nodes $N_*$ of $\mathcal{T}$ in file `leaf-nodes/N*.json`

Every leaf node is either optimal or infeasible. 

A leaf node is _infeasible_ if 


f_x(y) = prod_d (||y-x||^2 - d^2)

polynomial of y1 y2
degree 2d

1 + 2 + 3 + ... + (2d + 1)
-> (d+1)(2d+1)

n linearly independent polynomials

n <= (d+1)(2d+1)

n=4

d=2
